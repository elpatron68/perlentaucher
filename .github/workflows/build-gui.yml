name: Build GUI Cross-Platform

on:
  push:
    tags:
      - 'v*'
  release:
    types: [created]
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  test:
    name: Run Tests (Python ${{ matrix.python-version }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-gui.txt
          pip install flake8
          # Installiere GUI-Test-Dependencies nur wenn PyQt6 verfügbar ist
          pip install -r requirements-test-gui.txt 2>/dev/null || echo "GUI-Test-Dependencies übersprungen (PyQt6 nicht verfügbar)"
      
      - name: Linting mit flake8
        run: |
          echo "=== Linting mit flake8 ==="
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Python Syntax prüfen
        run: |
          echo "=== Python Syntax prüfen ==="
          python -m py_compile perlentaucher.py
          python -m py_compile perlentaucher_gui.py
          python -m py_compile gui/*.py gui/utils/*.py 2>/dev/null || true
      
      - name: Test: --help Option
        run: |
          echo "=== Test: --help Option ==="
          python perlentaucher.py --help
      
      - name: Test: Dry-run
        run: |
          echo "=== Test: Dry-run ==="
          python perlentaucher.py --limit 1 --loglevel DEBUG --download-dir /tmp/test_downloads || true
      
      - name: Run Unit Tests
        run: |
          echo "=== Running Unit Tests ==="
          pytest tests/ -v --tb=short --ignore=tests/test_gui_components.py -m "not gui and not slow and not network" || true
      
      - name: Run Tests with Coverage
        run: |
          echo "=== Running Tests with Coverage ==="
          pytest tests/ -v --cov=. --cov=perlentaucher --cov=gui --cov-report=term-missing --cov-report=xml --cov-report=html --ignore=tests/test_gui_components.py -m "not gui and not slow and not network" || true
      
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}
          verbose: true
      
      - name: Upload Coverage HTML Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report-${{ matrix.python-version }}
          path: htmlcov/
          retention-days: 7
      
      - name: Tests abgeschlossen
        run: |
          echo "=== Tests abgeschlossen ==="
  
  build:
    needs: test
    name: Build GUI (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libxcb-xinerama0 \
            libxcb-cursor0 \
            libegl1 \
            libxkbcommon-x11-0 \
            libxkbcommon0 \
            xvfb

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew install python@3.11 || true

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-gui.txt
          pip install --upgrade pyinstaller

      - name: Build with PyInstaller (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          pyinstaller build.spec --clean --noconfirm
        shell: pwsh

      - name: Build with PyInstaller (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          pyinstaller build.spec --clean --noconfirm

      - name: Build with PyInstaller (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # Auf macOS erstellt PyInstaller mit --windowed automatisch ein .app Bundle
          # Versuche zuerst mit build.spec, dann mit direkter Kommandozeile
          echo "Building with build.spec..."
          pyinstaller build.spec --clean --noconfirm --windowed 2>&1 || {
            echo "Build with spec failed, trying direct command..."
            pyinstaller --windowed --name PerlentaucherGUI \
              --hidden-import=feedparser \
              --hidden-import=requests \
              --hidden-import=apprise \
              --hidden-import=semver \
              --hidden-import=PyQt6 \
              --hidden-import=PyQt6.QtCore \
              --hidden-import=PyQt6.QtWidgets \
              --hidden-import=PyQt6.QtGui \
              --hidden-import=perlentaucher \
              --clean --noconfirm \
              perlentaucher_gui.py 2>&1
          }
          echo ""
          echo "Build output in dist/:"
          ls -la dist/ 2>/dev/null || echo "dist/ not found"

      - name: Determine artifact name (Windows)
        if: matrix.os == 'windows-latest'
        id: artifact-windows
        run: |
          $version = (python -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)").Trim()
          $artifact = "PerlentaucherGUI-$version-windows.exe"
          echo "name=$artifact" >> $env:GITHUB_OUTPUT
          echo "path=dist\PerlentaucherGUI.exe" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Determine artifact name (Linux)
        if: matrix.os == 'ubuntu-latest'
        id: artifact-linux
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)")
          ARTIFACT="PerlentaucherGUI-$VERSION-linux"
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=dist/PerlentaucherGUI" >> $GITHUB_OUTPUT

      - name: Determine artifact name (macOS)
        if: matrix.os == 'macos-latest'
        id: artifact-macos
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)")
          
          # Prüfe ob .app Bundle existiert
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          elif [ -f "dist/PerlentaucherGUI" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos"
            ARTIFACT_PATH="dist/PerlentaucherGUI"
            ARTIFACT_TYPE="exe"
          else
            # Fallback: verwende .app Name
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          fi
          
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT
          echo "type=$ARTIFACT_TYPE" >> $GITHUB_OUTPUT

      - name: Verify build output exists (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          if (Test-Path "dist\PerlentaucherGUI.exe") { Write-Host "✓ Windows build successful" } else { Write-Host "✗ Windows build failed"; exit 1 }
        shell: pwsh

      - name: Verify build output exists (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ -f "dist/PerlentaucherGUI" ]; then echo "✓ Linux build successful"; else echo "✗ Linux build failed"; exit 1; fi

      - name: Verify build output exists (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Checking for build output..."
          echo "Contents of dist/:"
          ls -la dist/ 2>/dev/null || echo "dist/ not found"
          echo ""
          echo "Searching for app bundle or executable:"
          APP_BUNDLE=""
          EXECUTABLE=""
          
          # Suche nach .app Bundle
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            APP_BUNDLE="dist/PerlentaucherGUI.app"
            echo "✓ Found PerlentaucherGUI.app bundle at: $APP_BUNDLE"
          elif find dist -name "*.app" -type d | head -1 | read app_path; then
            APP_BUNDLE="$app_path"
            echo "✓ Found app bundle at: $APP_BUNDLE"
          fi
          
          # Suche nach Executable
          if [ -f "dist/PerlentaucherGUI" ]; then
            EXECUTABLE="dist/PerlentaucherGUI"
            echo "✓ Found PerlentaucherGUI executable at: $EXECUTABLE"
          elif find dist -name "PerlentaucherGUI" -type f | head -1 | read exe_path; then
            EXECUTABLE="$exe_path"
            echo "✓ Found executable at: $EXECUTABLE"
          fi
          
          # Wenn kein Bundle, aber Executable vorhanden, versuche Bundle zu erstellen
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "ℹ No app bundle found, but executable exists. PyInstaller should create .app automatically."
            echo "  Checking if PyInstaller creates it with different command..."
          fi
          
          # Fehler, wenn nichts gefunden wurde
          if [ -z "$APP_BUNDLE" ] && [ -z "$EXECUTABLE" ]; then
            echo "✗ No build output found in dist/"
            echo "Available files in dist/:"
            find dist -type f -o -type d 2>/dev/null | head -20 || echo "dist/ directory is empty"
            exit 1
          fi
          
          # Setze APP_BUNDLE wenn Executable vorhanden aber kein Bundle
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "⚠ Warning: Only executable found, no .app bundle. This might cause issues."
          fi

      - name: Rename artifact (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Move-Item -Path "dist\PerlentaucherGUI.exe" -Destination "dist\${{ steps.artifact-windows.outputs.name }}"
        shell: pwsh

      - name: Rename artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-linux.outputs.name }}"

      - name: Create ZIP archive (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Compress-Archive -Path "dist\${{ steps.artifact-windows.outputs.name }}" -DestinationPath "dist\${{ steps.artifact-windows.outputs.name }}.zip" -Force
        shell: pwsh

      - name: Create TAR.GZ archive (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          tar -czf "dist/${{ steps.artifact-linux.outputs.name }}.tar.gz" -C dist "${{ steps.artifact-linux.outputs.name }}"

      - name: Rename artifact (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          if [ "${{ steps.artifact-macos.outputs.type }}" = "app" ] && [ -d "dist/PerlentaucherGUI.app" ]; then
            # App Bundle bereits vorhanden, benenne es um
            mv "dist/PerlentaucherGUI.app" "dist/${{ steps.artifact-macos.outputs.name }}"
          elif [ "${{ steps.artifact-macos.outputs.type }}" = "exe" ] && [ -f "dist/PerlentaucherGUI" ]; then
            # Executable vorhanden, benenne es um
            mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-macos.outputs.name }}"
          else
            echo "ℹ Artifact already has correct name or not found"
          fi

      - name: Create ZIP archive (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          cd dist
          if [ -d "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip -r "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          elif [ -f "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          else
            echo "⚠ Artifact not found for archiving: ${{ steps.artifact-macos.outputs.name }}"
            exit 1
          fi
          cd ..

      - name: List build artifacts (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          Get-ChildItem -Path dist -Recurse | Format-Table Name, Length, LastWriteTime
        shell: pwsh
        continue-on-error: true

      - name: List build artifacts (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          ls -lh dist/
        continue-on-error: true

      - name: Upload artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-windows-${{ github.sha }}
          path: dist/*.exe*
          retention-days: 30

      - name: Upload artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-linux-${{ github.sha }}
          path: dist/PerlentaucherGUI*
          retention-days: 30

      - name: Upload artifact (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-macos-${{ github.sha }}
          path: dist/PerlentaucherGUI*
          retention-days: 30

  release:
    name: Create Release Assets
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          elif [ -n "${{ github.ref }}" ]; then
            # Extrahiere Tag aus refs/tags/v1.2.3
            VERSION=$(echo "${{ github.ref }}" | sed 's|refs/tags/||' | sed 's|^v||')
          else
            VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)" 2>/dev/null || echo "unknown")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Tag version: $VERSION"

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          # Kopiere alle Build-Artefakte, aber keine PyInstaller-Interna
          find artifacts -type f \( -name "*.exe" -o -name "*.exe.zip" -o -name "*.tar.gz" -o -name "*.zip" -o -name "PerlentaucherGUI" -o -name "PerlentaucherGUI-*" \) | while read file; do
            filename=$(basename "$file")
            # Filtere PyInstaller-Interne Dateien heraus
            if [ "$filename" != "base_library.zip" ]; then
              cp "$file" "release-assets/"
            fi
          done
          echo "Release assets prepared:"
          ls -lh release-assets/

      - name: Determine release tag
        id: release-tag
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          elif [ -n "${{ github.ref }}" ]; then
            # Extrahiere Tag aus refs/tags/v1.2.3
            TAG=$(echo "${{ github.ref }}" | sed 's|refs/tags/||')
          else
            TAG="v${{ steps.version.outputs.version }}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Release tag: $TAG"

      - name: Upload release assets to GitHub
        uses: softprops/action-gh-release@v2
        if: github.event_name == 'release'
        with:
          files: release-assets/*
          tag_name: ${{ steps.release-tag.outputs.tag || github.event.release.tag_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  upload-to-codeberg:
    name: Upload Assets to Codeberg
    needs: release
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare assets for upload
        id: prepare
        run: |
          mkdir -p codeberg-assets
          # Kopiere alle Build-Artefakte (ZIP/TAR.GZ Dateien bevorzugen, aber keine PyInstaller-Interna)
          find artifacts -type f \( -name "*.exe.zip" -o -name "*.tar.gz" -o -name "*.zip" -o -name "*.exe" -o -name "PerlentaucherGUI-*" \) | while read file; do
            filename=$(basename "$file")
            # Filtere PyInstaller-Interne Dateien heraus
            if [ "$filename" != "base_library.zip" ]; then
              cp "$file" "codeberg-assets/$filename"
            fi
          done
          
          echo "Assets prepared for Codeberg upload:"
          ls -lh codeberg-assets/
          
          # Zähle Dateien
          FILE_COUNT=$(find codeberg-assets -type f | wc -l)
          echo "count=$FILE_COUNT" >> $GITHUB_OUTPUT

      - name: Check Codeberg Token
        id: check-token
        run: |
          if [ -z "${{ secrets.CODEBERG_TOKEN }}" ]; then
            echo "⚠ CODEBERG_TOKEN secret not found. Skipping Codeberg upload."
            echo "has_token=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "✓ CODEBERG_TOKEN secret found"
            echo "has_token=true" >> $GITHUB_OUTPUT
          fi

      - name: Get Codeberg Release ID
        id: get-release
        if: steps.check-token.outputs.has_token == 'true'
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_TAG: ${{ steps.release-tag.outputs.tag || github.event.release.tag_name || github.ref_name }}
        run: |
          echo "Looking for release with tag: $RELEASE_TAG"
          echo "Repository: $CODEBERG_REPO"
          
          # Hole Release-ID über Tag
          RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token $CODEBERG_TOKEN" \
            "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/tags/$RELEASE_TAG" 2>/dev/null)
          
          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | tail -n1)
          RELEASE_JSON=$(echo "$RELEASE_RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" = "200" ] && [ -n "$RELEASE_JSON" ] && [ "$RELEASE_JSON" != "null" ]; then
            RELEASE_ID=$(echo "$RELEASE_JSON" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            if [ -n "$RELEASE_ID" ]; then
              echo "✓ Found Codeberg release ID: $RELEASE_ID"
              echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
              # Extrahiere URL sicher mit sed
              RELEASE_URL=$(echo "$RELEASE_JSON" | sed -n 's/.*"html_url":"\([^"]*\)".*/\1/p')
              if [ -n "$RELEASE_URL" ]; then
                echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠ Could not extract release ID from response"
              exit 1
            fi
          else
            echo "⚠ Release not found on Codeberg (HTTP $HTTP_CODE)"
            echo "Response: $RELEASE_JSON"
            echo "ℹ Make sure the release was created on Codeberg first (via release script)"
            echo "ℹ The release script should create the release before triggering GitHub Actions"
            exit 1
          fi

      - name: Upload assets to Codeberg
        if: steps.check-token.outputs.has_token == 'true' && steps.get-release.outputs.release_id != ''
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_ID: ${{ steps.get-release.outputs.release_id }}
        run: |
          if [ -z "$RELEASE_ID" ]; then
            echo "⚠ No release ID found, skipping upload"
            exit 1
          fi
          
          if [ "${{ steps.prepare.outputs.count }}" = "0" ]; then
            echo "⚠ No assets found to upload"
            exit 1
          fi
          
          echo "Uploading assets to Codeberg release ID: $RELEASE_ID"
          UPLOADED=0
          FAILED=0
          
          for file in codeberg-assets/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "Uploading: $filename"
              
              # Codeberg/Gitea API: Upload asset
              UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Authorization: token $CODEBERG_TOKEN" \
                -F "attachment=@$file;filename=$filename" \
                "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" 2>/dev/null)
              
              HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | tail -n1)
              
              if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
                echo "  ✓ Successfully uploaded: $filename"
                UPLOADED=$((UPLOADED + 1))
              else
                echo "  ✗ Failed to upload: $filename (HTTP $HTTP_CODE)"
                echo "    Response: $(echo "$UPLOAD_RESPONSE" | head -n-1)"
                FAILED=$((FAILED + 1))
              fi
            fi
          done
          
          echo ""
          echo "Upload summary:"
          echo "  ✓ Uploaded: $UPLOADED files"
          echo "  ✗ Failed: $FAILED files"
          
          if [ "$FAILED" -gt 0 ]; then
            echo "⚠ Some uploads failed. Check the logs above."
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          echo "## Codeberg Upload Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.get-release.outputs.release_url }}" ]; then
            echo "✅ Assets uploaded to Codeberg Release: [${{ steps.get-release.outputs.release_url }}]" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠ Release not found on Codeberg. Make sure the release was created first." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Uploaded ${{ steps.prepare.outputs.count }} assets to Codeberg." >> $GITHUB_STEP_SUMMARY
