name: Build GUI Cross-Platform

on:
  push:
    branches:
      - main
      - master
      - 'feature/**'
    paths:
      - '**.py'
      - 'build.spec'
      - 'requirements*.txt'
      - '.github/workflows/build-gui.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '**.py'
      - 'build.spec'
      - 'requirements*.txt'
      - '.github/workflows/build-gui.yml'
  release:
    types: [created]
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  build:
    name: Build GUI (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libxcb-xinerama0 \
            libxcb-cursor0 \
            libegl1 \
            libxkbcommon-x11-0 \
            libxkbcommon0 \
            xvfb

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew install python@3.11 || true

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-gui.txt
          pip install --upgrade pyinstaller

      - name: Build with PyInstaller (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          pyinstaller build.spec --clean --noconfirm
        shell: pwsh

      - name: Build with PyInstaller (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          pyinstaller build.spec --clean --noconfirm

      - name: Build with PyInstaller (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # Auf macOS erstellt PyInstaller mit --windowed automatisch ein .app Bundle
          # Versuche zuerst mit build.spec, dann mit direkter Kommandozeile
          echo "Building with build.spec..."
          pyinstaller build.spec --clean --noconfirm --windowed 2>&1 || {
            echo "Build with spec failed, trying direct command..."
            pyinstaller --windowed --name PerlentaucherGUI \
              --hidden-import=feedparser \
              --hidden-import=requests \
              --hidden-import=apprise \
              --hidden-import=semver \
              --hidden-import=PyQt6 \
              --hidden-import=PyQt6.QtCore \
              --hidden-import=PyQt6.QtWidgets \
              --hidden-import=PyQt6.QtGui \
              --hidden-import=perlentaucher \
              --clean --noconfirm \
              perlentaucher_gui.py 2>&1
          }
          echo ""
          echo "Build output in dist/:"
          ls -la dist/ 2>/dev/null || echo "dist/ not found"

      - name: Determine artifact name (Windows)
        if: matrix.os == 'windows-latest'
        id: artifact-windows
        run: |
          $version = (python -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)").Trim()
          $artifact = "PerlentaucherGUI-$version-windows.exe"
          echo "name=$artifact" >> $env:GITHUB_OUTPUT
          echo "path=dist\PerlentaucherGUI.exe" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Determine artifact name (Linux)
        if: matrix.os == 'ubuntu-latest'
        id: artifact-linux
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)")
          ARTIFACT="PerlentaucherGUI-$VERSION-linux"
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=dist/PerlentaucherGUI" >> $GITHUB_OUTPUT

      - name: Determine artifact name (macOS)
        if: matrix.os == 'macos-latest'
        id: artifact-macos
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)")
          
          # Prüfe ob .app Bundle existiert
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          elif [ -f "dist/PerlentaucherGUI" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos"
            ARTIFACT_PATH="dist/PerlentaucherGUI"
            ARTIFACT_TYPE="exe"
          else
            # Fallback: verwende .app Name
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          fi
          
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT
          echo "type=$ARTIFACT_TYPE" >> $GITHUB_OUTPUT

      - name: Verify build output exists (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          if (Test-Path "dist\PerlentaucherGUI.exe") { Write-Host "✓ Windows build successful" } else { Write-Host "✗ Windows build failed"; exit 1 }
        shell: pwsh

      - name: Verify build output exists (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ -f "dist/PerlentaucherGUI" ]; then echo "✓ Linux build successful"; else echo "✗ Linux build failed"; exit 1; fi

      - name: Verify build output exists (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Checking for build output..."
          echo "Contents of dist/:"
          ls -la dist/ 2>/dev/null || echo "dist/ not found"
          echo ""
          echo "Searching for app bundle or executable:"
          APP_BUNDLE=""
          EXECUTABLE=""
          
          # Suche nach .app Bundle
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            APP_BUNDLE="dist/PerlentaucherGUI.app"
            echo "✓ Found PerlentaucherGUI.app bundle at: $APP_BUNDLE"
          elif find dist -name "*.app" -type d | head -1 | read app_path; then
            APP_BUNDLE="$app_path"
            echo "✓ Found app bundle at: $APP_BUNDLE"
          fi
          
          # Suche nach Executable
          if [ -f "dist/PerlentaucherGUI" ]; then
            EXECUTABLE="dist/PerlentaucherGUI"
            echo "✓ Found PerlentaucherGUI executable at: $EXECUTABLE"
          elif find dist -name "PerlentaucherGUI" -type f | head -1 | read exe_path; then
            EXECUTABLE="$exe_path"
            echo "✓ Found executable at: $EXECUTABLE"
          fi
          
          # Wenn kein Bundle, aber Executable vorhanden, versuche Bundle zu erstellen
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "ℹ No app bundle found, but executable exists. PyInstaller should create .app automatically."
            echo "  Checking if PyInstaller creates it with different command..."
          fi
          
          # Fehler, wenn nichts gefunden wurde
          if [ -z "$APP_BUNDLE" ] && [ -z "$EXECUTABLE" ]; then
            echo "✗ No build output found in dist/"
            echo "Available files in dist/:"
            find dist -type f -o -type d 2>/dev/null | head -20 || echo "dist/ directory is empty"
            exit 1
          fi
          
          # Setze APP_BUNDLE wenn Executable vorhanden aber kein Bundle
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "⚠ Warning: Only executable found, no .app bundle. This might cause issues."
          fi

      - name: Rename artifact (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Move-Item -Path "dist\PerlentaucherGUI.exe" -Destination "dist\${{ steps.artifact-windows.outputs.name }}"
        shell: pwsh

      - name: Rename artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-linux.outputs.name }}"

      - name: Create ZIP archive (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Compress-Archive -Path "dist\${{ steps.artifact-windows.outputs.name }}" -DestinationPath "dist\${{ steps.artifact-windows.outputs.name }}.zip" -Force
        shell: pwsh

      - name: Create TAR.GZ archive (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          tar -czf "dist/${{ steps.artifact-linux.outputs.name }}.tar.gz" -C dist "${{ steps.artifact-linux.outputs.name }}"

      - name: Rename artifact (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          if [ "${{ steps.artifact-macos.outputs.type }}" = "app" ] && [ -d "dist/PerlentaucherGUI.app" ]; then
            # App Bundle bereits vorhanden, benenne es um
            mv "dist/PerlentaucherGUI.app" "dist/${{ steps.artifact-macos.outputs.name }}"
          elif [ "${{ steps.artifact-macos.outputs.type }}" = "exe" ] && [ -f "dist/PerlentaucherGUI" ]; then
            # Executable vorhanden, benenne es um
            mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-macos.outputs.name }}"
          else
            echo "ℹ Artifact already has correct name or not found"
          fi

      - name: Create ZIP archive (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          cd dist
          if [ -d "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip -r "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          elif [ -f "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          else
            echo "⚠ Artifact not found for archiving: ${{ steps.artifact-macos.outputs.name }}"
            exit 1
          fi
          cd ..

      - name: List build artifacts (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          Get-ChildItem -Path dist -Recurse | Format-Table Name, Length, LastWriteTime
        shell: pwsh
        continue-on-error: true

      - name: List build artifacts (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          ls -lh dist/
        continue-on-error: true

      - name: Upload artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-windows-${{ github.sha }}
          path: dist/*.exe*
          retention-days: 30

      - name: Upload artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-linux-${{ github.sha }}
          path: dist/PerlentaucherGUI*
          retention-days: 30

      - name: Upload artifact (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-macos-${{ github.sha }}
          path: dist/PerlentaucherGUI*
          retention-days: 30

  release:
    name: Create Release Assets
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine version
        id: version
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from _version import __version__; print(__version__)" 2>/dev/null || echo "${{ github.event.release.tag_name }}")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          find artifacts -type f \( -name "*.exe" -o -name "*.exe.zip" -o -name "*.tar.gz" -o -name "*.zip" -o -name "PerlentaucherGUI" -o -name "PerlentaucherGUI-*" \) -exec cp {} release-assets/ \;
          echo "Release assets prepared:"
          ls -lh release-assets/

      - name: Upload release assets to GitHub
        uses: softprops/action-gh-release@v2
        with:
          files: release-assets/*
          tag_name: ${{ github.event.release.tag_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  upload-to-codeberg:
    name: Upload Assets to Codeberg
    needs: release
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare assets for upload
        id: prepare
        run: |
          mkdir -p codeberg-assets
          # Kopiere alle Build-Artefakte (ZIP/TAR.GZ Dateien bevorzugen)
          find artifacts -type f \( -name "*.exe.zip" -o -name "*.tar.gz" -o -name "*.zip" -o -name "*.exe" -o -name "PerlentaucherGUI-*" \) | while read file; do
            filename=$(basename "$file")
            cp "$file" "codeberg-assets/$filename"
          done
          
          echo "Assets prepared for Codeberg upload:"
          ls -lh codeberg-assets/
          
          # Zähle Dateien
          FILE_COUNT=$(find codeberg-assets -type f | wc -l)
          echo "count=$FILE_COUNT" >> $GITHUB_OUTPUT

      - name: Check Codeberg Token
        id: check-token
        run: |
          if [ -z "${{ secrets.CODEBERG_TOKEN }}" ]; then
            echo "⚠ CODEBERG_TOKEN secret not found. Skipping Codeberg upload."
            echo "has_token=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "✓ CODEBERG_TOKEN secret found"
            echo "has_token=true" >> $GITHUB_OUTPUT
          fi

      - name: Get Codeberg Release ID
        id: get-release
        if: steps.check-token.outputs.has_token == 'true'
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          echo "Looking for release with tag: $RELEASE_TAG"
          echo "Repository: $CODEBERG_REPO"
          
          # Hole Release-ID über Tag
          RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token $CODEBERG_TOKEN" \
            "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/tags/$RELEASE_TAG" 2>/dev/null)
          
          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | tail -n1)
          RELEASE_JSON=$(echo "$RELEASE_RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" = "200" ] && [ -n "$RELEASE_JSON" ] && [ "$RELEASE_JSON" != "null" ]; then
            RELEASE_ID=$(echo "$RELEASE_JSON" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            if [ -n "$RELEASE_ID" ]; then
              echo "✓ Found Codeberg release ID: $RELEASE_ID"
              echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
              echo "release_url=$(echo "$RELEASE_JSON" | grep -o '"html_url":"[^"]*"' | cut -d'"' -f4)" >> $GITHUB_OUTPUT
            else
              echo "⚠ Could not extract release ID from response"
              exit 1
            fi
          else
            echo "⚠ Release not found on Codeberg (HTTP $HTTP_CODE)"
            echo "Response: $RELEASE_JSON"
            echo "ℹ Make sure the release was created on Codeberg first (via release script)"
            echo "ℹ The release script should create the release before triggering GitHub Actions"
            exit 1
          fi

      - name: Upload assets to Codeberg
        if: steps.check-token.outputs.has_token == 'true' && steps.get-release.outputs.release_id != ''
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO_OWNER: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_ID: ${{ steps.get-release.outputs.release_id }}
        run: |
          # Extrahiere owner/repo Format aus CODEBERG_REPO_OWNER (kann URL oder owner/repo sein)
          if [[ "$CODEBERG_REPO_OWNER" =~ ^https?://[^/]+/([^/]+)/([^/]+) ]]; then
            CODEBERG_REPO="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
          elif [[ "$CODEBERG_REPO_OWNER" =~ ^[^/]+/[^/]+$ ]]; then
            CODEBERG_REPO="$CODEBERG_REPO_OWNER"
          else
            CODEBERG_REPO="elpatron/perlentaucher"
          fi
          if [ -z "$RELEASE_ID" ]; then
            echo "⚠ No release ID found, skipping upload"
            exit 1
          fi
          
          if [ "${{ steps.prepare.outputs.count }}" = "0" ]; then
            echo "⚠ No assets found to upload"
            exit 1
          fi
          
          echo "Uploading assets to Codeberg release ID: $RELEASE_ID"
          UPLOADED=0
          FAILED=0
          
          for file in codeberg-assets/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "Uploading: $filename"
              
              # Codeberg/Gitea API: Upload asset
              UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Authorization: token $CODEBERG_TOKEN" \
                -F "attachment=@$file;filename=$filename" \
                "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" 2>/dev/null)
              
              HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | tail -n1)
              
              if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "200" ]; then
                echo "  ✓ Successfully uploaded: $filename"
                UPLOADED=$((UPLOADED + 1))
              else
                echo "  ✗ Failed to upload: $filename (HTTP $HTTP_CODE)"
                echo "    Response: $(echo "$UPLOAD_RESPONSE" | head -n-1)"
                FAILED=$((FAILED + 1))
              fi
            fi
          done
          
          echo ""
          echo "Upload summary:"
          echo "  ✓ Uploaded: $UPLOADED files"
          echo "  ✗ Failed: $FAILED files"
          
          if [ "$FAILED" -gt 0 ]; then
            echo "⚠ Some uploads failed. Check the logs above."
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          echo "## Codeberg Upload Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.get-release.outputs.release_url }}" ]; then
            echo "✅ Assets uploaded to Codeberg Release: [${{ steps.get-release.outputs.release_url }}]" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠ Release not found on Codeberg. Make sure the release was created first." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Uploaded ${{ steps.prepare.outputs.count }} assets to Codeberg." >> $GITHUB_STEP_SUMMARY
