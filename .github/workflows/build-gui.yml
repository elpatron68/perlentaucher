name: Build GUI Cross-Platform

on:
  push:
    tags:
      - 'v*'
  release:
    types: [created]
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  test:
    name: Run Tests (Python ${{ matrix.python-version }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-gui.txt
          pip install flake8
          # Installiere GUI-Test-Dependencies nur wenn PyQt6 verfügbar ist
          pip install -r requirements-test-gui.txt 2>/dev/null || echo "GUI-Test-Dependencies übersprungen (PyQt6 nicht verfügbar)"
      
      - name: Linting mit flake8
        run: |
          echo "=== Linting mit flake8 ==="
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Python Syntax prüfen
        run: |
          echo "=== Python Syntax prüfen ==="
          python -m py_compile src/perlentaucher.py
          python -m py_compile src/perlentaucher_gui.py
          python -m py_compile src/gui/*.py src/gui/utils/*.py 2>/dev/null || true
      
      - name: Test --help Option
        run: |
          echo "=== Test: --help Option ==="
          python src/perlentaucher.py --help
      
      - name: Test Dry-run
        run: |
          echo "=== Test: Dry-run ==="
          python src/perlentaucher.py --limit 1 --loglevel DEBUG --download-dir /tmp/test_downloads || true
      
      - name: Run Unit Tests
        run: |
          echo "=== Running Unit Tests ==="
          pytest tests/ -v --tb=short --ignore=tests/test_gui_components.py -m "not gui and not slow and not network" || true
      
      - name: Run Tests with Coverage
        id: coverage
        run: |
          echo "=== Running Tests with Coverage ==="
          pytest tests/ -v --cov=. --cov=src.perlentaucher --cov=src.gui --cov-report=term-missing --cov-report=xml --cov-report=html --ignore=tests/test_gui_components.py -m "not gui and not slow and not network" || true
          
          # Prüfe ob Coverage-Dateien erstellt wurden
          if [ -f "coverage.xml" ]; then
            echo "coverage_xml_exists=true" >> $GITHUB_OUTPUT
            echo "✓ coverage.xml gefunden"
          else
            echo "coverage_xml_exists=false" >> $GITHUB_OUTPUT
            echo "⚠ coverage.xml nicht gefunden"
          fi
          
          if [ -d "htmlcov" ] && [ "$(ls -A htmlcov 2>/dev/null)" ]; then
            echo "htmlcov_exists=true" >> $GITHUB_OUTPUT
            echo "✓ htmlcov/ gefunden"
          else
            echo "htmlcov_exists=false" >> $GITHUB_OUTPUT
            echo "⚠ htmlcov/ nicht gefunden oder leer"
          fi
      
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v4
        if: always() && steps.coverage.outputs.coverage_xml_exists == 'true' && (github.event_name == 'push' || github.event_name == 'pull_request')
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}
          verbose: true
        continue-on-error: true
      
      - name: Upload Coverage HTML Report
        uses: actions/upload-artifact@v4
        if: always() && steps.coverage.outputs.htmlcov_exists == 'true'
        with:
          name: coverage-report-${{ matrix.python-version }}
          path: htmlcov/
          retention-days: 7
        continue-on-error: true
      
      - name: Tests abgeschlossen
        run: |
          echo "=== Tests abgeschlossen ==="
  
  build:
    needs: test
    name: Build GUI (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libxcb-xinerama0 \
            libxcb-cursor0 \
            libegl1 \
            libxkbcommon-x11-0 \
            libxkbcommon0 \
            xvfb

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew install python@3.11 || true

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-gui.txt
          # PyInstaller 5.0+ wird für --target-arch universal2 benötigt
          pip install --upgrade "pyinstaller>=5.0"
        
      - name: Install Pillow for macOS icon conversion
        if: matrix.os == 'macos-latest'
        run: |
          # Pillow wird benötigt um .ico Icons auf macOS zu .icns zu konvertieren
          # Installiere Pillow als Universal Binary für --target-arch universal2
          echo "=== Installing Pillow as Universal Binary ==="
          pip uninstall -y Pillow || true
          # Installiere Pillow als Universal Binary (Intel + Apple Silicon)
          ARCHFLAGS='-arch arm64 -arch x86_64' pip install --no-binary=:all: Pillow || {
            echo "⚠ Building Pillow from source failed, trying to install universal2 wheel if available..."
            # Fallback: Versuche universal2 wheel zu finden
            pip install Pillow --upgrade || {
              echo "✗ Failed to install Pillow as Universal Binary"
              exit 1
            }
          }
          echo "✓ Pillow installed"
        
      - name: Reinstall PyYAML as Universal Binary (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "=== Reinstalling PyYAML as Universal Binary ==="
          # Deinstalliere aktuelles PyYAML
          pip uninstall -y PyYAML || true
          # Installiere PyYAML als Universal Binary (Intel + Apple Silicon)
          # ARCHFLAGS wird verwendet um beide Architekturen zu kompilieren
          ARCHFLAGS='-arch arm64 -arch x86_64' pip install --no-binary=:all: PyYAML || {
            echo "⚠ Building from source failed, trying to install universal2 wheel if available..."
            # Fallback: Versuche universal2 wheel zu finden
            pip install PyYAML --upgrade || {
              echo "✗ Failed to install PyYAML as Universal Binary"
              exit 1
            }
          }
          echo "✓ PyYAML reinstalled"
          # Verifiziere dass PyYAML Universal Binary ist
          python3 -c "import yaml; import yaml._yaml; import os; lib_path = yaml._yaml.__file__; print(f'PyYAML library: {lib_path}'); os.system(f'file {lib_path}')" || echo "⚠ Could not verify PyYAML architecture"

      - name: Build with PyInstaller (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          pyinstaller build.spec --clean --noconfirm
        shell: pwsh

      - name: Build with PyInstaller (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          pyinstaller build.spec --clean --noconfirm

      - name: Build with PyInstaller (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          set -e
          echo "=== Building macOS Universal Binary (Intel + Apple Silicon) ==="
          echo "Python version: $(python3 --version)"
          echo "PyInstaller version: $(pyinstaller --version)"
          echo "Current architecture: $(uname -m)"
          echo ""
          
          # Prüfe ob Python Universal Binary ist
          PYTHON_ARCH=$(file $(which python3) | grep -o "x86_64\|arm64" | head -1 || echo "unknown")
          echo "Python architecture: $PYTHON_ARCH"
          
          # Verifiziere dass PyYAML Universal Binary ist (wichtig für --target-arch universal2)
          echo ""
          echo "=== Verifying PyYAML is Universal Binary ==="
          python3 -c "import yaml; import yaml._yaml; import os; lib_path = yaml._yaml.__file__; print(f'PyYAML library: {lib_path}'); result = os.popen(f'file {lib_path}').read(); print(result); assert 'x86_64' in result or 'arm64' in result or 'universal' in result, 'PyYAML is not a Universal Binary'" || {
            echo "⚠ PyYAML verification failed, but continuing..."
          }
          
          # Auf macOS erstellt PyInstaller mit console=False automatisch ein .app Bundle
          # WICHTIG: Für Universal Binary MUSS --target-arch universal2 verwendet werden
          echo ""
          echo "=== Building universal2 app (Intel + Apple Silicon) ==="
          
          # Prüfe ob --target-arch unterstützt wird
          if ! pyinstaller --help 2>&1 | grep -q "target-arch"; then
            echo "✗ ERROR: PyInstaller does not support --target-arch"
            echo "This is required for Universal Binary creation!"
            echo "Please upgrade PyInstaller to version 5.0 or later"
            pyinstaller --version
            exit 1
          fi
          
          echo "✓ PyInstaller supports --target-arch, building universal2 binary..."
          echo "⚠ Note: --target-arch cannot be used with .spec files, using direct command instead"
          
          # WICHTIG: --target-arch funktioniert NICHT mit .spec Dateien
          # Verwende direkten PyInstaller-Befehl für Universal Binary
          # Versuche zuerst mit Icon (Pillow sollte .ico zu .icns konvertieren)
          if pyinstaller --windowed --name PerlentaucherGUI \
              --target-arch universal2 \
              --hidden-import=feedparser \
              --hidden-import=requests \
              --hidden-import=urllib3 \
              --hidden-import=urllib3.util.ssl_ \
              --hidden-import=apprise \
              --hidden-import=semver \
              --hidden-import=PyQt6 \
              --hidden-import=PyQt6.QtCore \
              --hidden-import=PyQt6.QtWidgets \
              --hidden-import=PyQt6.QtGui \
              --hidden-import=src.perlentaucher \
              --add-data "assets:assets" \
              --icon=assets/icon.ico \
              --clean --noconfirm \
              src/perlentaucher_gui.py 2>&1; then
            echo "✓ Build with icon successful"
          else
            # Fallback: Versuche ohne Icon falls Icon-Konvertierung fehlschlägt
            echo "⚠ Build with icon failed, trying without icon..."
            pyinstaller --windowed --name PerlentaucherGUI \
              --target-arch universal2 \
              --hidden-import=feedparser \
              --hidden-import=requests \
              --hidden-import=urllib3 \
              --hidden-import=urllib3.util.ssl_ \
              --hidden-import=apprise \
              --hidden-import=semver \
              --hidden-import=PyQt6 \
              --hidden-import=PyQt6.QtCore \
              --hidden-import=PyQt6.QtWidgets \
              --hidden-import=PyQt6.QtGui \
              --hidden-import=src.perlentaucher \
              --add-data "assets:assets" \
              --clean --noconfirm \
              src/perlentaucher_gui.py 2>&1 || {
              echo "✗ All build methods failed"
              echo "Build logs:"
              cat build/*.log 2>/dev/null || echo "No build logs found"
              exit 1
            }
          fi
          
          echo ""
          echo "=== Build output in dist/ ==="
          ls -la dist/ 2>/dev/null || { echo "✗ dist/ directory not found"; exit 1; }
          echo ""
          
          # Prüfe ob .app Bundle oder Executable erstellt wurde
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            echo "✓ Found PerlentaucherGUI.app bundle"
            echo "App bundle size:"
            du -sh "dist/PerlentaucherGUI.app"
            echo ""
            echo "=== Verifying Universal Binary architecture ==="
            if [ -f "dist/PerlentaucherGUI.app/Contents/MacOS/PerlentaucherGUI" ]; then
              EXECUTABLE="dist/PerlentaucherGUI.app/Contents/MacOS/PerlentaucherGUI"
              file "$EXECUTABLE"
              
              # Prüfe ob es ein Universal Binary ist (sollte beide Architekturen enthalten)
              ARCHS=$(lipo -archs "$EXECUTABLE" 2>/dev/null || echo "")
              echo "Architectures in binary: $ARCHS"
              
              if echo "$ARCHS" | grep -q "x86_64" && echo "$ARCHS" | grep -q "arm64"; then
                echo "✓ SUCCESS: Universal Binary created (Intel + Apple Silicon)"
              elif echo "$ARCHS" | grep -q "x86_64"; then
                echo "⚠ WARNING: Only Intel (x86_64) architecture found"
                echo "  This is NOT a Universal Binary!"
                exit 1
              elif echo "$ARCHS" | grep -q "arm64"; then
                echo "⚠ WARNING: Only Apple Silicon (arm64) architecture found"
                echo "  This is NOT a Universal Binary!"
                exit 1
              else
                echo "⚠ WARNING: Could not determine architecture"
                echo "  Verifying with lipo -info:"
                lipo -info "$EXECUTABLE" || echo "  lipo command failed"
              fi
            else
              echo "✗ Executable not found in app bundle"
              exit 1
            fi
          elif [ -f "dist/PerlentaucherGUI" ]; then
            echo "✓ Found PerlentaucherGUI executable (no .app bundle)"
            file "dist/PerlentaucherGUI"
            ARCHS=$(lipo -archs "dist/PerlentaucherGUI" 2>/dev/null || echo "")
            echo "Architectures in binary: $ARCHS"
            if echo "$ARCHS" | grep -q "x86_64" && echo "$ARCHS" | grep -q "arm64"; then
              echo "✓ SUCCESS: Universal Binary created (Intel + Apple Silicon)"
            else
              echo "⚠ WARNING: Not a Universal Binary!"
              exit 1
            fi
          else
            echo "✗ No build output found in dist/"
            echo "Contents of dist/:"
            find dist -type f -o -type d | head -20
            exit 1
          fi

      - name: Determine artifact name (Windows)
        if: matrix.os == 'windows-latest'
        id: artifact-windows
        run: |
          $version = (python -c "import sys; sys.path.insert(0, '.'); from src._version import __version__; print(__version__)").Trim()
          $artifact = "PerlentaucherGUI-$version-windows.exe"
          echo "name=$artifact" >> $env:GITHUB_OUTPUT
          echo "path=dist\PerlentaucherGUI.exe" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Determine artifact name (Linux)
        if: matrix.os == 'ubuntu-latest'
        id: artifact-linux
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from src._version import __version__; print(__version__)")
          ARTIFACT="PerlentaucherGUI-$VERSION-linux"
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=dist/PerlentaucherGUI" >> $GITHUB_OUTPUT

      - name: Determine artifact name (macOS)
        if: matrix.os == 'macos-latest'
        id: artifact-macos
        run: |
          VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from src._version import __version__; print(__version__)")
          
          # Prüfe ob .app Bundle existiert
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          elif [ -f "dist/PerlentaucherGUI" ]; then
            ARTIFACT="PerlentaucherGUI-$VERSION-macos"
            ARTIFACT_PATH="dist/PerlentaucherGUI"
            ARTIFACT_TYPE="exe"
          else
            # Fallback: verwende .app Name
            ARTIFACT="PerlentaucherGUI-$VERSION-macos.app"
            ARTIFACT_PATH="dist/PerlentaucherGUI.app"
            ARTIFACT_TYPE="app"
          fi
          
          echo "name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "path=$ARTIFACT_PATH" >> $GITHUB_OUTPUT
          echo "type=$ARTIFACT_TYPE" >> $GITHUB_OUTPUT

      - name: Verify build output exists (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          if (Test-Path "dist\PerlentaucherGUI.exe") { Write-Host "✓ Windows build successful" } else { Write-Host "✗ Windows build failed"; exit 1 }
        shell: pwsh

      - name: Verify build output exists (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ -f "dist/PerlentaucherGUI" ]; then echo "✓ Linux build successful"; else echo "✗ Linux build failed"; exit 1; fi

      - name: Verify build output exists (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Checking for build output..."
          echo "Contents of dist/:"
          ls -la dist/ 2>/dev/null || echo "dist/ not found"
          echo ""
          echo "Searching for app bundle or executable:"
          APP_BUNDLE=""
          EXECUTABLE=""
          
          # Suche nach .app Bundle
          if [ -d "dist/PerlentaucherGUI.app" ]; then
            APP_BUNDLE="dist/PerlentaucherGUI.app"
            echo "✓ Found PerlentaucherGUI.app bundle at: $APP_BUNDLE"
          elif find dist -name "*.app" -type d | head -1 | read app_path; then
            APP_BUNDLE="$app_path"
            echo "✓ Found app bundle at: $APP_BUNDLE"
          fi
          
          # Suche nach Executable
          if [ -f "dist/PerlentaucherGUI" ]; then
            EXECUTABLE="dist/PerlentaucherGUI"
            echo "✓ Found PerlentaucherGUI executable at: $EXECUTABLE"
          elif find dist -name "PerlentaucherGUI" -type f | head -1 | read exe_path; then
            EXECUTABLE="$exe_path"
            echo "✓ Found executable at: $EXECUTABLE"
          fi
          
          # Wenn kein Bundle, aber Executable vorhanden, versuche Bundle zu erstellen
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "ℹ No app bundle found, but executable exists. PyInstaller should create .app automatically."
            echo "  Checking if PyInstaller creates it with different command..."
          fi
          
          # Fehler, wenn nichts gefunden wurde
          if [ -z "$APP_BUNDLE" ] && [ -z "$EXECUTABLE" ]; then
            echo "✗ No build output found in dist/"
            echo "Available files in dist/:"
            find dist -type f -o -type d 2>/dev/null | head -20 || echo "dist/ directory is empty"
            exit 1
          fi
          
          # Setze APP_BUNDLE wenn Executable vorhanden aber kein Bundle
          if [ -z "$APP_BUNDLE" ] && [ -n "$EXECUTABLE" ]; then
            echo "⚠ Warning: Only executable found, no .app bundle. This might cause issues."
          fi

      - name: Rename artifact (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Move-Item -Path "dist\PerlentaucherGUI.exe" -Destination "dist\${{ steps.artifact-windows.outputs.name }}"
        shell: pwsh

      - name: Rename artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-linux.outputs.name }}"

      - name: Create ZIP archive (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Compress-Archive -Path "dist\${{ steps.artifact-windows.outputs.name }}" -DestinationPath "dist\${{ steps.artifact-windows.outputs.name }}.zip" -Force
        shell: pwsh

      - name: Create TAR.GZ archive (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          tar -czf "dist/${{ steps.artifact-linux.outputs.name }}.tar.gz" -C dist "${{ steps.artifact-linux.outputs.name }}"

      - name: Rename artifact (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          if [ "${{ steps.artifact-macos.outputs.type }}" = "app" ] && [ -d "dist/PerlentaucherGUI.app" ]; then
            # App Bundle bereits vorhanden, benenne es um
            mv "dist/PerlentaucherGUI.app" "dist/${{ steps.artifact-macos.outputs.name }}"
          elif [ "${{ steps.artifact-macos.outputs.type }}" = "exe" ] && [ -f "dist/PerlentaucherGUI" ]; then
            # Executable vorhanden, benenne es um
            mv "dist/PerlentaucherGUI" "dist/${{ steps.artifact-macos.outputs.name }}"
          else
            echo "ℹ Artifact already has correct name or not found"
          fi

      - name: Create ZIP archive (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          cd dist
          if [ -d "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip -r "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          elif [ -f "${{ steps.artifact-macos.outputs.name }}" ]; then
            zip "${{ steps.artifact-macos.outputs.name }}.zip" "${{ steps.artifact-macos.outputs.name }}"
          else
            echo "⚠ Artifact not found for archiving: ${{ steps.artifact-macos.outputs.name }}"
            exit 1
          fi
          cd ..

      - name: List build artifacts (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          Get-ChildItem -Path dist -Recurse | Format-Table Name, Length, LastWriteTime
        shell: pwsh
        continue-on-error: true

      - name: List build artifacts (Linux/macOS)
        if: matrix.os != 'windows-latest'
        run: |
          echo "Build artifacts in dist/:"
          ls -lh dist/
        continue-on-error: true

      - name: Verify artifacts before upload (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          $exeFile = "dist\${{ steps.artifact-windows.outputs.name }}"
          $zipFile = "dist\${{ steps.artifact-windows.outputs.name }}.zip"
          if (-not (Test-Path $exeFile)) { Write-Host "✗ EXE not found: $exeFile"; exit 1 }
          if (-not (Test-Path $zipFile)) { Write-Host "✗ ZIP not found: $zipFile"; exit 1 }
          Write-Host "✓ All Windows artifacts verified"
        shell: pwsh

      - name: Upload artifact (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-windows-${{ github.sha }}
          path: |
            dist/${{ steps.artifact-windows.outputs.name }}
            dist/${{ steps.artifact-windows.outputs.name }}.zip
          retention-days: 7

      - name: Verify artifacts before upload (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          if [ ! -f "dist/${{ steps.artifact-linux.outputs.name }}" ]; then
            echo "✗ Executable not found: dist/${{ steps.artifact-linux.outputs.name }}"
            exit 1
          fi
          if [ ! -f "dist/${{ steps.artifact-linux.outputs.name }}.tar.gz" ]; then
            echo "✗ TAR.GZ not found: dist/${{ steps.artifact-linux.outputs.name }}.tar.gz"
            exit 1
          fi
          echo "✓ All Linux artifacts verified"
          ls -lh "dist/${{ steps.artifact-linux.outputs.name }}"*
        continue-on-error: true

      - name: Upload artifact (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: PerlentaucherGUI-linux-${{ github.sha }}
          path: |
            dist/${{ steps.artifact-linux.outputs.name }}
            dist/${{ steps.artifact-linux.outputs.name }}.tar.gz
          retention-days: 7

      - name: Verify artifacts before upload (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Checking for macOS artifacts..."
          if [ "${{ steps.artifact-macos.outputs.type }}" = "app" ]; then
            if [ ! -d "dist/${{ steps.artifact-macos.outputs.name }}" ]; then
              echo "✗ App bundle not found: dist/${{ steps.artifact-macos.outputs.name }}"
              exit 1
            fi
            if [ ! -f "dist/${{ steps.artifact-macos.outputs.name }}.zip" ]; then
              echo "✗ ZIP not found: dist/${{ steps.artifact-macos.outputs.name }}.zip"
              exit 1
            fi
          else
            if [ ! -f "dist/${{ steps.artifact-macos.outputs.name }}" ]; then
              echo "✗ Executable not found: dist/${{ steps.artifact-macos.outputs.name }}"
              exit 1
            fi
            if [ ! -f "dist/${{ steps.artifact-macos.outputs.name }}.zip" ]; then
              echo "✗ ZIP not found: dist/${{ steps.artifact-macos.outputs.name }}.zip"
              exit 1
            fi
          fi
          echo "✓ All macOS artifacts verified"
          ls -lh "dist/${{ steps.artifact-macos.outputs.name }}"*
        continue-on-error: true

      - name: Upload artifact (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: PerlentaucherGUI-macos-${{ github.sha }}
          path: |
            dist/${{ steps.artifact-macos.outputs.name }}
            dist/${{ steps.artifact-macos.outputs.name }}.zip
          retention-days: 7

  release:
    name: Create Release Assets
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          elif [ -n "${{ github.ref }}" ]; then
            # Extrahiere Tag aus refs/tags/v1.2.3
            VERSION=$(echo "${{ github.ref }}" | sed 's|refs/tags/||' | sed 's|^v||')
          else
            VERSION=$(python3 -c "import sys; sys.path.insert(0, '.'); from src._version import __version__; print(__version__)" 2>/dev/null || echo "unknown")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Tag version: $VERSION"

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          # Kopiere alle Build-Artefakte, aber keine PyInstaller-Interna
          find artifacts -type f \( -name "*.exe" -o -name "*.exe.zip" -o -name "*.tar.gz" -o -name "*.zip" -o -name "PerlentaucherGUI" -o -name "PerlentaucherGUI-*" \) | while read file; do
            filename=$(basename "$file")
            # Filtere PyInstaller-Interne Dateien heraus
            if [ "$filename" != "base_library.zip" ]; then
              cp "$file" "release-assets/"
            fi
          done
          echo "Release assets prepared:"
          ls -lh release-assets/

      - name: Determine release tag
        id: release-tag
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          elif [ -n "${{ github.ref }}" ]; then
            # Extrahiere Tag aus refs/tags/v1.2.3
            TAG=$(echo "${{ github.ref }}" | sed 's|refs/tags/||')
          else
            TAG="v${{ steps.version.outputs.version }}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Release tag: $TAG"

      - name: Upload release assets to GitHub
        uses: softprops/action-gh-release@v2
        if: github.event_name == 'release'
        with:
          files: release-assets/*
          tag_name: ${{ steps.release-tag.outputs.tag || github.event.release.tag_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  upload-to-codeberg:
    name: Upload Assets to Codeberg
    needs: release
    runs-on: ubuntu-latest
    if: github.event_name == 'release' || startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare assets for upload
        id: prepare
        run: |
          mkdir -p codeberg-assets
          
          echo "=== DEBUG: Listing all artifacts ==="
          find artifacts -type f -o -type d | sort
          echo ""
          
          # Kopiere ALLE Build-Artefakte (komprimiert UND unkomprimiert)
          # WICHTIG: Sammle zuerst alle eindeutigen Dateinamen, dann kopiere nur einmal
          
          echo "=== Collecting ALL build artifacts (compressed AND uncompressed) ==="
          
          # Schritt 1: Sammle alle eindeutigen Dateinamen (verhindert Duplikate beim Kopieren)
          ALL_FILENAMES=$(mktemp)
          
          # Sammle alle komprimierten Dateien
          echo "--- Step 1: Collect compressed file names ---"
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" -o -name "*.exe.zip" -o -name "*.app.zip" \) -exec basename {} \; | \
            grep -v "^base_library\.zip$" | \
            sort -u >> "$ALL_FILENAMES"
          
          # Sammle alle unkomprimierten Dateien
          echo "--- Step 2: Collect uncompressed file names ---"
          find artifacts -type f \( -name "*.exe" ! -name "*.zip" -o -name "PerlentaucherGUI-*-linux" ! -name "*.zip" ! -name "*.tar.gz" ! -name "*.exe" \) -exec basename {} \; | \
            grep -v "^base_library\.zip$" | \
            sort -u >> "$ALL_FILENAMES"
          
          # Sammle .app Bundle Namen
          find artifacts -type d -name "*.app" -exec basename {} \; | sort -u >> "$ALL_FILENAMES"
          
          # Dedupliziere die gesamte Liste
          sort -u "$ALL_FILENAMES" > "${ALL_FILENAMES}.sorted"
          mv "${ALL_FILENAMES}.sorted" "$ALL_FILENAMES"
          
          echo ""
          echo "--- Step 3: Copy unique files to codeberg-assets/ ---"
          
          # Schritt 2: Kopiere jede eindeutige Datei nur einmal
          while IFS= read -r filename; do
            if [ -z "$filename" ]; then
              continue
            fi
            
            # Überspringe base_library.zip
            if [ "$filename" = "base_library.zip" ]; then
              continue
            fi
            
            # Prüfe ob Datei bereits in codeberg-assets/ existiert
            if [ -f "codeberg-assets/$filename" ]; then
              echo "  ⊘ Already copied: $filename"
              continue
            fi
            
            # Suche nach dieser Datei in artifacts (nimmt erste gefundene)
            source_file=$(find artifacts -type f -name "$filename" | head -n1)
            if [ -n "$source_file" ] && [ -f "$source_file" ]; then
              cp "$source_file" "codeberg-assets/$filename"
              echo "  ✓ Copied: $filename"
              continue
            fi
            
            # Wenn keine Datei gefunden wurde, könnte es ein .app Bundle sein
            app_dir=$(find artifacts -type d -name "$filename" | head -n1)
            if [ -n "$app_dir" ] && [ -d "$app_dir" ]; then
              # Erstelle TAR.GZ aus .app Bundle (falls noch nicht vorhanden)
              tar_filename="${filename}.tar.gz"
              zip_filename="${filename}.zip"
              # Nur erstellen wenn weder .tar.gz noch .zip bereits existiert
              if [ ! -f "codeberg-assets/$tar_filename" ] && [ ! -f "codeberg-assets/$zip_filename" ]; then
                tar -czf "codeberg-assets/$tar_filename" -C "$(dirname "$app_dir")" "$filename"
                echo "  ✓ Created compressed from .app: $tar_filename"
              else
                echo "  ⊘ Skipped .app (compressed version already exists): $filename"
              fi
            fi
          done < "$ALL_FILENAMES"
          
          rm -f "$ALL_FILENAMES"
          
          echo ""
          echo "=== Final assets prepared for Codeberg upload ==="
          ls -lh codeberg-assets/ | sort
          echo ""
          
          # Zähle eindeutige Dateien
          FILE_COUNT=$(find codeberg-assets -type f | wc -l)
          echo "count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "Prepared $FILE_COUNT unique assets for upload (compressed + uncompressed)"

      - name: Check Codeberg Token
        id: check-token
        run: |
          if [ -z "${{ secrets.CODEBERG_TOKEN }}" ]; then
            echo "⚠ CODEBERG_TOKEN secret not found. Skipping Codeberg upload."
            echo "has_token=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "✓ CODEBERG_TOKEN secret found"
            echo "has_token=true" >> $GITHUB_OUTPUT
          fi

      - name: Get Codeberg Release ID
        id: get-release
        if: steps.check-token.outputs.has_token == 'true'
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_TAG: ${{ steps.release-tag.outputs.tag || github.event.release.tag_name || github.ref_name }}
        run: |
          echo "Looking for release with tag: $RELEASE_TAG"
          echo "Repository: $CODEBERG_REPO"
          
          # Hole Release-ID über Tag
          RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token $CODEBERG_TOKEN" \
            "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/tags/$RELEASE_TAG" 2>/dev/null)
          
          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | tail -n1)
          RELEASE_JSON=$(echo "$RELEASE_RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" = "200" ] && [ -n "$RELEASE_JSON" ] && [ "$RELEASE_JSON" != "null" ]; then
            RELEASE_ID=$(echo "$RELEASE_JSON" | grep -o '"id":[0-9]*' | head -1 | cut -d':' -f2)
            if [ -n "$RELEASE_ID" ]; then
              echo "✓ Found Codeberg release ID: $RELEASE_ID"
              echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
              # Extrahiere URL sicher mit sed
              RELEASE_URL=$(echo "$RELEASE_JSON" | sed -n 's/.*"html_url":"\([^"]*\)".*/\1/p')
              if [ -n "$RELEASE_URL" ]; then
                echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
              fi
            else
              echo "⚠ Could not extract release ID from response"
              exit 1
            fi
          else
            echo "⚠ Release not found on Codeberg (HTTP $HTTP_CODE)"
            echo "Response: $RELEASE_JSON"
            echo "ℹ Make sure the release was created on Codeberg first (via release script)"
            echo "ℹ The release script should create the release before triggering GitHub Actions"
            exit 1
          fi

      - name: Upload assets to Codeberg
        if: steps.check-token.outputs.has_token == 'true' && steps.get-release.outputs.release_id != ''
        env:
          CODEBERG_TOKEN: ${{ secrets.CODEBERG_TOKEN }}
          CODEBERG_REPO: ${{ secrets.CODEBERG_REPO_OWNER || 'elpatron/perlentaucher' }}
          RELEASE_ID: ${{ steps.get-release.outputs.release_id }}
        run: |
          if [ -z "$RELEASE_ID" ]; then
            echo "⚠ No release ID found, skipping upload"
            exit 1
          fi
          
          if [ "${{ steps.prepare.outputs.count }}" = "0" ]; then
            echo "⚠ No assets found to upload"
            exit 1
          fi
          
          echo "Uploading assets to Codeberg release ID: $RELEASE_ID"
          
          # Hole Liste der bereits vorhandenen Assets vom Release
          echo "Checking for existing assets..."
          EXISTING_ASSETS_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token $CODEBERG_TOKEN" \
            "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" 2>/dev/null)
          EXISTING_HTTP_CODE=$(echo "$EXISTING_ASSETS_RESPONSE" | tail -n1)
          EXISTING_ASSETS_JSON=$(echo "$EXISTING_ASSETS_RESPONSE" | head -n-1)
          
          # Extrahiere bereits vorhandene Dateinamen in eine temporäre Datei für zuverlässige Prüfung
          EXISTING_NAMES_FILE=$(mktemp)
          if [ "$EXISTING_HTTP_CODE" = "200" ] && [ -n "$EXISTING_ASSETS_JSON" ]; then
            echo "$EXISTING_ASSETS_JSON" | grep -o '"name":"[^"]*"' | sed 's/"name":"\([^"]*\)"/\1/' > "$EXISTING_NAMES_FILE" || true
            EXISTING_COUNT=$(wc -l < "$EXISTING_NAMES_FILE" | tr -d ' ')
            if [ "$EXISTING_COUNT" -gt 0 ]; then
              echo "Found $EXISTING_COUNT existing assets:"
              cat "$EXISTING_NAMES_FILE" | while read name; do
                if [ -n "$name" ]; then
                  echo "  - $name"
                fi
              done
            else
              echo "No existing assets found"
            fi
          else
            echo "Could not fetch existing assets (HTTP $EXISTING_HTTP_CODE)"
            touch "$EXISTING_NAMES_FILE"
          fi
          
          # Erstelle eindeutige Dateiliste für Upload (verhindert Duplikate)
          # WICHTIG: Verwende process substitution oder Array, um Subshell-Probleme zu vermeiden
          echo "Creating unique file list for upload..."
          
          # Erstelle temporäre Datei mit eindeutigen Dateinamen
          # Sammle zuerst alle Dateinamen, dann dedupliziere mit sort -u
          ALL_FILES=$(mktemp)
          find codeberg-assets -type f -exec basename {} \; | sort -u > "$ALL_FILES"
          
          # Filtere base_library.zip heraus
          grep -v "^base_library\.zip$" "$ALL_FILES" > "${ALL_FILES}.filtered"
          mv "${ALL_FILES}.filtered" "$ALL_FILES"
          
          # Erstelle Mapping-Datei: filename -> filepath (nimmt erste gefundene Datei)
          FILES_TO_UPLOAD=$(mktemp)
          
          # Für jeden eindeutigen Dateinamen finde den ersten Pfad
          while IFS= read -r filename; do
            if [ -z "$filename" ]; then
              continue
            fi
            # Finde erste Datei mit diesem Namen
            filepath=$(find codeberg-assets -type f -name "$filename" | head -n1)
            if [ -n "$filepath" ] && [ -f "$filepath" ]; then
              echo "$filename|$filepath" >> "$FILES_TO_UPLOAD"
            fi
          done < "$ALL_FILES"
          
          # Zähle eindeutige Dateien
          UNIQUE_COUNT=$(wc -l < "$FILES_TO_UPLOAD" | tr -d ' ' || echo "0")
          echo "Found $UNIQUE_COUNT unique files to upload"
          if [ "$UNIQUE_COUNT" -gt 0 ]; then
            echo "Files to upload:"
            cut -d'|' -f1 "$FILES_TO_UPLOAD" | sed 's/^/  - /'
          fi
          echo ""
          
          UPLOADED=0
          SKIPPED=0
          FAILED=0
          
          # Hilfsfunktion: Aktualisiere EXISTING_NAMES_FILE von Codeberg API
          update_existing_assets() {
            local temp_response=$(mktemp)
            curl -s -w "\n%{http_code}" \
              -H "Authorization: token $CODEBERG_TOKEN" \
              "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" > "$temp_response" 2>/dev/null || return 1
            
            local http_code=$(tail -n1 "$temp_response")
            local response_body=$(head -n-1 "$temp_response")
            
            if [ "$http_code" = "200" ] && [ -n "$response_body" ]; then
              echo "$response_body" | grep -o '"name":"[^"]*"' | sed 's/"name":"\([^"]*\)"/\1/' > "$EXISTING_NAMES_FILE" || true
              rm -f "$temp_response"
              return 0
            fi
            rm -f "$temp_response"
            return 1
          }
          
          # Iteriere über eindeutige Dateiliste (jede Zeile: filename|filepath)
          # WICHTIG: Verwende Redirection statt Pipe, um Subshell-Probleme zu vermeiden
          while IFS='|' read -r filename filepath; do
            # Überspringe leere Zeilen
            if [ -z "$filepath" ] || [ -z "$filename" ]; then
              continue
            fi
            
            # Prüfe ob Datei existiert
            if [ ! -f "$filepath" ]; then
              echo "⚠ File not found: $filepath"
              continue
            fi
            
            echo "Processing: $filename"
            
            # WICHTIG: Prüfe IMMER zuerst ob Datei bereits auf Codeberg vorhanden ist
            # Aktualisiere Liste vor jedem Upload, um sicherzustellen dass wir die neueste Liste haben
            # Dies verhindert Duplikate wenn mehrere Uploads nacheinander laufen
            if grep -Fxq "$filename" "$EXISTING_NAMES_FILE" 2>/dev/null; then
              echo "  ⊘ Skipping (already exists on Codeberg): $filename"
              SKIPPED=$((SKIPPED + 1))
              continue
            fi
            
            # Zusätzliche Prüfung: Hole aktuelle Asset-Liste von Codeberg API
            # Dies stellt sicher, dass wir die neueste Liste haben (falls ein anderer Prozess hochgeladen hat)
            CURRENT_ASSETS=$(curl -s -H "Authorization: token $CODEBERG_TOKEN" \
              "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" 2>/dev/null || echo "[]")
            
            # Prüfe ob Datei bereits in aktueller Asset-Liste vorhanden ist
            if echo "$CURRENT_ASSETS" | grep -q "\"name\":\"$filename\""; then
              echo "  ⊘ Skipping (found in current Codeberg assets): $filename"
              echo "$filename" >> "$EXISTING_NAMES_FILE"
              SKIPPED=$((SKIPPED + 1))
              continue
            fi
            
            echo "  Uploading: $filename"
            
            # Codeberg/Gitea API: Upload asset
            UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Authorization: token $CODEBERG_TOKEN" \
              -F "attachment=@$filepath;filename=$filename" \
              "https://codeberg.org/api/v1/repos/$CODEBERG_REPO/releases/$RELEASE_ID/assets" 2>/dev/null)
            
            HTTP_CODE=$(echo "$UPLOAD_RESPONSE" | tail -n1)
            UPLOAD_BODY=$(echo "$UPLOAD_RESPONSE" | head -n-1)
            
            if [ "$HTTP_CODE" = "201" ]; then
              # HTTP 201 = Created (neue Datei erfolgreich hochgeladen)
              echo "  ✓ Successfully uploaded: $filename (HTTP 201 - Created)"
              UPLOADED=$((UPLOADED + 1))
              # WICHTIG: Füge SOFORT zur Liste hinzu, um Duplikate im gleichen Run zu vermeiden
              echo "$filename" >> "$EXISTING_NAMES_FILE"
            elif [ "$HTTP_CODE" = "200" ]; then
              # HTTP 200 = OK (Datei könnte bereits existieren oder wurde aktualisiert)
              # Prüfe Response Body, ob die Datei wirklich hochgeladen wurde
              if echo "$UPLOAD_BODY" | grep -q '"id"'; then
                echo "  ✓ Successfully uploaded: $filename (HTTP 200 - OK)"
                UPLOADED=$((UPLOADED + 1))
                echo "$filename" >> "$EXISTING_NAMES_FILE"
              else
                echo "  ⊘ Skipping (HTTP 200 but no asset ID in response - possibly already exists): $filename"
                echo "$filename" >> "$EXISTING_NAMES_FILE"
                SKIPPED=$((SKIPPED + 1))
              fi
            elif [ "$HTTP_CODE" = "422" ]; then
              # HTTP 422 = Unprocessable Entity (oft bedeutet das, dass die Datei bereits existiert)
              echo "  ⊘ Skipping (HTTP 422 - file already exists): $filename"
              echo "$filename" >> "$EXISTING_NAMES_FILE"
              SKIPPED=$((SKIPPED + 1))
            elif [ "$HTTP_CODE" = "409" ]; then
              # HTTP 409 = Conflict (Datei existiert bereits)
              echo "  ⊘ Skipping (HTTP 409 - file already exists): $filename"
              echo "$filename" >> "$EXISTING_NAMES_FILE"
              SKIPPED=$((SKIPPED + 1))
            else
              echo "  ✗ Failed to upload: $filename (HTTP $HTTP_CODE)"
              echo "    Response: $UPLOAD_BODY"
              FAILED=$((FAILED + 1))
            fi
            
            # Kurze Pause zwischen Uploads, um Race Conditions zu vermeiden
            sleep 0.5
          done < "$FILES_TO_UPLOAD"
          
          # Aufräumen
          rm -f "$EXISTING_NAMES_FILE" "$FILES_TO_UPLOAD" "$ALL_FILES"
          
          echo ""
          echo "Upload summary:"
          echo "  ✓ Uploaded: $UPLOADED files"
          echo "  ⊘ Skipped (already exists): $SKIPPED files"
          echo "  ✗ Failed: $FAILED files"
          
          if [ "$FAILED" -gt 0 ]; then
            echo "⚠ Some uploads failed. Check the logs above."
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          echo "## Codeberg Upload Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.get-release.outputs.release_url }}" ]; then
            echo "✅ Assets uploaded to Codeberg Release: [${{ steps.get-release.outputs.release_url }}]" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠ Release not found on Codeberg. Make sure the release was created first." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Uploaded ${{ steps.prepare.outputs.count }} assets to Codeberg." >> $GITHUB_STEP_SUMMARY
